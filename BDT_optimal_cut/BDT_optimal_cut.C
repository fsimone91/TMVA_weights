#include "TH1F.h"
#include <cmath>

double TH1_integral (TH1F *h, float xmin, float xmax){
    TAxis *axis = h->GetXaxis();
    int bmin = axis->FindBin(xmin);
    int bmax = axis->FindBin(xmax);
    double integral = h->Integral(bmin,bmax);
    integral -= h->GetBinContent(bmin)*(xmin-axis->GetBinLowEdge(bmin))/axis->GetBinWidth(bmin);
    integral -= h->GetBinContent(bmax)*(axis->GetBinUpEdge(bmax)-xmax)/ axis->GetBinWidth(bmax);

    return integral;
}
void BDT_optimal_cut() 
{
    //pull path of root files generated by TMVA
    TString file_name[3] = {"TMVA_file_A.root",
                            "TMVA_file_B.root",
                            "TMVA_file_C.root"};
    TString cat_name[3] = {"catA",
                           "catB",
                           "catC"};
    float a,b;
    double N_s_1, N_b_1;
    double N_s_2, N_b_2;
    double S1, S2, S;
    std::vector<double> S1_list, S2_list, S_list, a_list, b_list;

    for(int k=0; k<3; k++)
    {
	    TFile *f = new TFile(file_name[k],"READ");

	    TH1F *h_test_signal;
	    TH1F *h_test_bkg;
	    h_test_signal = (TH1F*)f->Get("dataset/Method_BDT/BDT/MVA_BDT_S");
	    h_test_bkg = (TH1F*)f->Get("dataset/Method_BDT/BDT/MVA_BDT_B");

	    //Histograms are normalized to 1 -> to be improved
	    h_test_signal->Scale(1/(h_test_signal->Integral()));
	    h_test_bkg->Scale(1/(h_test_bkg->Integral()));
	    //Make up on plots
	    h_test_signal->GetXaxis()->SetRangeUser(-0.5,0.5);
	    h_test_signal->GetYaxis()->SetRangeUser(0,0.11);
	    h_test_signal->SetLineColor(kRed);

            //Loop on both cuts in [-0.5;0.5]
	    Int_t dim = 0;
	    for(int i=0; i<21; i++){
		a = -0.5 + i * 0.05;
		for(int j=0; j<21; j++){
		    b = -0.5 + j * 0.05;
                    //computing areas in range [a;0.5] and [b;a]
		    N_s_1 = TH1_integral(h_test_signal,a,0.5);
		    N_b_1 = TH1_integral(h_test_bkg,a,0.5);
		    N_s_2 = TH1_integral(h_test_signal,b,a);
		    N_b_2 = TH1_integral(h_test_bkg,b,a);
		    if ( (N_b_1)>0 && (N_b_2)>0 ) {
			S1 = N_s_1 / sqrt(N_b_1);
			S2 = N_s_2 / sqrt(N_b_2);
			//S1 = sqrt( 2*( (N_s_1+N_b_1)*log(1+ (N_s_1/N_b_1)) - N_s_1 ) );
			//S2 = sqrt( 2*( (N_s_2+N_b_2)*log(1+ (N_s_2/N_b_2)) - N_s_2 ) );
			//Combined significance
			S = sqrt(S1*S1 + S2*S2);
			a_list.push_back(a);
			b_list.push_back(b);
			S_list.push_back(S);
			dim++;
		    }
		}
	    }
	    
	    TCanvas *c3 = new TCanvas("c3","c3",150,10,990,660);
	    TGraph2D *g2d = new TGraph2D(dim, &a_list[0], &b_list[0], &S_list[0]);
	    g2d->SetTitle(cat_name[k]+";b;a");
	    g2d->Draw("colz");    

            //Taking absolute maximum of the combined significance
	    double S_max = *max_element(S_list.begin(), S_list.end());
	    int S_maxIndex = std::max_element(S_list.begin(),S_list.end()) - S_list.begin();
	    cout<<"b corresponding to maximum "<<b_list.at(S_maxIndex)<<endl;
	    cout<<"a corresponding to maximum "<<a_list.at(S_maxIndex)<<endl;
	    cout<<"S value: "<<S_max<<endl;
	    float a_max = a_list.at(S_maxIndex);
	    float b_max = b_list.at(S_maxIndex);
	    
            TLine l;
            l.DrawLine(a_max,-0.5,a_max,0.3);
            l.DrawLine(-0.5,b_max,0.3,b_max);

	    c3->Update();
	    c3->SaveAs("BDT_2Dmap_"+cat_name[k]+".png");

	    TCanvas *c1 = new TCanvas("c1","c1",150,10,990,660);
	    h_test_signal->Draw();
	    h_test_bkg->Draw("same");
	    c1->Update();
            l.DrawLine(a_max,0,a_max,0.1);
            l.DrawLine(b_max,0,b_max,0.1);

	    TLegend*leg = new TLegend(0.1,0.7,0.48,0.9);
	    leg->AddEntry(h_test_signal,cat_name[k]+"_signal","f");
	    leg->AddEntry(h_test_bkg,cat_name[k]+"_bkg","f");
	    leg->Draw();
	    c1->Update();
            c1->SaveAs("BDT_"+cat_name[k]+".png");

	    S_list.clear();
	    S1_list.clear();
	    S2_list.clear();
	    a_list.clear();
	    b_list.clear();
     }
}
